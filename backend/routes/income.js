const express = require('express');
const router = express.Router();
const Income = require('../models/Income');
const authMiddleware = require('../middleware/authMiddleware'); // Import auth middleware

// GET: Get incomes, optionally filtered by year and month
router.get('/', authMiddleware, async (req, res) => { // Protect with authMiddleware
  try {
    const { year, month } = req.query;
    let filter = { user: req.user.id }; // Initialize filter with user ID

    const now = new Date();
    const currentYear = now.getUTCFullYear();
    const currentMonth = now.getUTCMonth(); // 0-indexed

    // Auto-copy logic runs only for current month
    const startOfCurrentMonth = new Date(Date.UTC(currentYear, currentMonth, 1));
    const endOfCurrentMonth = new Date(Date.UTC(currentYear, currentMonth + 1, 1));

    // Check if any income exists in the current month for the user
    const incomeExists = await Income.exists({
      user: req.user.id, // Add user to filter
      date: { $gte: startOfCurrentMonth, $lt: endOfCurrentMonth }
    });

    if (!incomeExists) {
      // Get the most recent income before this month for the user
      const latestIncome = await Income.findOne({ user: req.user.id, date: { $lt: startOfCurrentMonth } }).sort({ date: -1 }); // Add user to filter
      if (latestIncome) {
        const copiedIncome = new Income({
          amount: latestIncome.amount,
          source: latestIncome.source,
          date: startOfCurrentMonth,
          autoGenerated: true,
          user: req.user.id // Associate with user
        });
        await copiedIncome.save();
      }
    }

    // Apply year and month filter if present
    if (year) {
      const y = parseInt(year);
      if (!isNaN(y)) {
        if (month !== undefined && month !== '') {
          const m = parseInt(month);
          if (!isNaN(m)) {
            filter.date = {
              $gte: new Date(Date.UTC(y, m, 1)),
              $lt: new Date(Date.UTC(y, m + 1, 1))
            };
          } else {
            filter.date = {
              $gte: new Date(Date.UTC(y, 0, 1)),
              $lt: new Date(Date.UTC(y + 1, 0, 1))
            };
          }
        } else {
          filter.date = {
            $gte: new Date(Date.UTC(y, 0, 1)),
            $lt: new Date(Date.UTC(y + 1, 0, 1))
          };
        }
      }
    }

    const incomes = await Income.find(filter).sort({ date: 1 });
    res.json(incomes);
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
});

// POST: Add a new income
router.post('/', authMiddleware, async (req, res) => { // Protect with authMiddleware
  const { amount, source, date } = req.body;
  try {
    const newIncome = new Income({ 
      amount, 
      source, 
      date, 
      user: req.user.id // Associate with user
    });
    await newIncome.save();
    res.status(201).json(newIncome);
  } catch (err) {
    res.status(400).json({ message: err.message });
  }
});

// DELETE: Delete an income by ID
router.delete('/:id', authMiddleware, async (req, res) => { // Protect with authMiddleware
  try {
    // Optional: Add check to ensure user can only delete their own income records
    const income = await Income.findById(req.params.id);
    if (!income) {
      return res.status(404).json({ message: 'Income not found' });
    }
    if (income.user.toString() !== req.user.id) {
      return res.status(401).json({ message: 'User not authorized' });
    }
    const deletedIncome = await Income.findByIdAndDelete(req.params.id);
    if (!deletedIncome) return res.status(404).json({ message: 'Income not found after attempting delete' });
    res.json({ message: 'Income deleted' });
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
});

module.exports = router;